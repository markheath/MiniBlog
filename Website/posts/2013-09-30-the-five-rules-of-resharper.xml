<post>
  <title>The Five Rules of ReSharper</title>
  <slug>the-five-rules-of-resharper</slug>
  <author>Mark Heath</author>
  <pubDate>2013-09-30 17:42:00</pubDate>
  <lastModified>2013-09-30 17:42:11</lastModified>
  <content>&lt;p&gt;I recently managed to persuade my work to get &lt;a href="http://www.jetbrains.com/resharper/"&gt;ReSharper&lt;/a&gt; licences for our development team. I’ve been using it since I won a free copy at &lt;a href="http://www.meetup.com/DeveloperSouthCoast/"&gt;Developer South Coast&lt;/a&gt;, and after being initially opposed to the idea of such a heavy-duty Visual Studio extension, it has won me over and I’m relying on it increasingly in my daily work.&lt;/p&gt; &lt;p&gt;Last week I ran some training sessions for the developers at work to introduce them to its features, but also to warn against some ways in which the tool can be misused. Here’s my top five rules for using ReSharper (or any productivity tool for that matter). Let me know in the comments if you have any additional rules you’d add to the list.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;1. It’s Your Code&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;ReSharper can offer to delete unused methods or fields, or to refactor a loop into a single LINQ statement. It provides several automatic refactorings such as renaming things, extracting methods etc. On the whole these seem to be extremely reliable, and before long you’ll be triggering these refactorings without a second thought. &lt;/p&gt; &lt;p&gt;But when you commit, it is &lt;strong&gt;your&lt;/strong&gt; responsibility to ensure that the code works fully. Of course, the best way of doing this is having unit tests that you can run, so you can prove that when ReSharper deletes unused code, or refactors a loop, that everything still runs as expected. If you check in broken code, it is your responsibility alone - you can’t blame the tool. ReSharper sometimes gets it wrong (especially when detecting “redundant” code), but it never forces you to commit to source control. It’s your job to test that everything is still working as expected before committing your changes.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;2. They’re Only Suggestions&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/posts/files/the-five-rules-of-resharper-1.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: left; padding-top: 0px; padding-left: 0px; margin: 8px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" align="left" src="/posts/files/the-five-rules-of-resharper-1.png" width="38" height="133"&gt;&lt;/a&gt;&lt;a href="/posts/files/the-five-rules-of-resharper-2.png"&gt;&lt;img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; float: right; padding-top: 0px; padding-left: 0px; margin: 8px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" align="right" src="/posts/files/the-five-rules-of-resharper-2.png" width="33" height="134"&gt;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;ReSharper has a superb way of presenting the issues that it has found with the source file you are currently editing, by presenting a bar showing where in the file various errors and warnings are. &lt;/p&gt; &lt;p&gt;If you manage to eliminate them all, you are rewarded with a nice green tick, telling you that your code is now perfect. But this can lead to problems for people with an OCD tendency. They become obsessed by an overwhelming desire to make all of the warnings go away.&lt;/p&gt; &lt;p&gt;What you need to constantly bear in mind is that these are only &lt;em&gt;suggestions&lt;/em&gt;. And sometimes the code is actually better like it is. Resist the urge to make a change that you don’t agree with. If seeing the warning sign really upsets you then R# helpfully allows you to supress warnings by use of a comment.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;3. Keep code cleanup commits separate from regular commits&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;Fixing up the warnings that R# finds is so quick and easy, that you can find yourself wandering through a source file fixing all its suggestions without even thinking about it. The trouble comes when you ask someone to code review your bug-fix. They end up having to examine a huge diff, mostly nothing to do with fixing the bug. The solution here is simply to keep your bug-fix changes and your code cleanup changes separate. Or at least restrict the code cleanup to the immediate vicinity of the bug-fix.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;4. Avoid code cleanup in maintenance branches&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;If like us you have to maintain multiple legacy versions of your software then you probably have to merge bug-fixes between branches on a regular basis. For those merges to go well, you want minimal impact to code, and code cleanup (especially renaming things) can end up causing widespread changes which can make merges painful. So the approach I have adopted for our team is to make minimal changes to legacy branches, but allow the code in the very latest version to be cleaned up as it is worked on.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;5. Get it clean on first commit&lt;/strong&gt;&lt;/p&gt;  &lt;p&gt;Of course, the ideal is that when you write new code, you implement (or suppress) all of the R# suggestion &lt;em&gt;before&lt;/em&gt; committing to source control. That way my rules #3 and #4 become redundant. Make sure you set up a &lt;a href="http://www.jetbrains.com/resharper/webhelp/Configuring_ReSharper__Sharing_Configuration_Options.html"&gt;team shared R# settings file&lt;/a&gt; so everyone is working to the same standards.&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories>
    <category>Refactoring</category>
    <category>clean code</category>
  </categories>
  <comments />
</post>