<post>
  <title>SOLID Code is Mergeable Code</title>
  <slug>solid-code-is-mergeable-code</slug>
  <author>Mark Heath</author>
  <pubDate>2011-06-18 19:28:00</pubDate>
  <lastModified>2011-06-18 19:28:25</lastModified>
  <content>&lt;p&gt;Not every developer I speak to is convinced of the importance of adhering to the &lt;a href="http://en.wikipedia.org/wiki/Solid_%28object-oriented_design%29"&gt;“SOLID” principles&lt;/a&gt;. They can seem a bit too abstract and “computer sciency” and disconnected from the immediate needs of delivering working software on time. “SOLID makes writing unit tests easier? So what, the customer didn’t ask for unit tests, they asked for an order billing system”.  &lt;p&gt;But one of the very concrete benefits of adhering to SOLID is that it eases merging for projects that require parallel development on multiple branches. Many of the commercial products I have worked on have required old versions to be supported with bug fixes and new features for many years. It is not uncommon to have more than 10 active branches of code. As nice as it would be to simply require every customer to upgrade to the latest version, that is not possible in all commercial environments. &lt;p&gt;One customer took well over a year to roll out our product to all their numerous sites. During that time we released two new major versions of our software. Another customer requires a rigorous and lengthy approval testing phase before they will accept anything new at all. The result is that features and bug fixes often have to be merged through multiple branches, some of which have diverged significantly over the years. &lt;p&gt;&lt;i&gt;So how do the SOLID principles aid merging?&lt;/i&gt; &lt;p&gt;The &lt;b&gt;Single Responsibility Principle&lt;/b&gt; states that each class should only have a single reason to change. If you have a class that constantly requires changing on every branch, creating regular merge conflicts, the chances are it violates SRP. If each class has only a single responsibility there is only a merge conflict if both branches genuinely need to modify that single responsibility. &lt;p&gt;Classes that adhere to the &lt;b&gt;Open Closed Principle &lt;/b&gt;don’t need to be changed at all (except to fix bugs). Instead, they can be extended from the &lt;i&gt;outside&lt;/i&gt;. Two branches can therefore extend the same class in completely different ways without any merge conflict at all – each branch simply adds a new class to the project. &lt;p&gt;Designs that violate the &lt;b&gt;Liskov Substitution Principle&lt;/b&gt; result in lots of switch and if statements littered throughout the code, that must be modified every time we introduce a new subclass into the system. In the canonical ‘shapes’ example, when the Triangle class is introduced on one branch, and the Hexagon class is created on another, the merge is trivial if the code abides by LSP. If the code doesn’t, you can expect a &lt;i&gt;lot&lt;/i&gt; of merge conflicts as every place in the code that uses the Shape base class is likely to have been modified in both branches. &lt;p&gt;The &lt;b&gt;Interface Segregation Principle &lt;/b&gt;is in some ways the SRP for interfaces. If you adhere to ISP, you have many small, focused interfaces instead of few large, bloated interfaces. And the more your codebase is broken down into smaller parts, the lower the chances of two branches both needing to change the same files. &lt;p&gt;Finally, the &lt;b&gt;Dependency Inversion Principle&lt;/b&gt; might not at first glance seem relevant to merges. But every application of DIP is in fact also a separation of concerns. The concern of creating your dependencies is separated away from actually using them. So applying DIP is always a step in the direction of SRP, which means you have smaller classes with more focused responsibilities. But DIP has another power that turns out to be very relevant for merging. &lt;p&gt;Code that adheres to the Dependency Inversion Principle is &lt;i&gt;much&lt;/i&gt; easier to unit test. And a good suite of unit tests is an invaluable tool when merging lots of changes between parallel branches. This is because it is quite easily possible for merged code to compile and yet still be broken. When merges between branches are taking place on a weekly basis, there is simply not enough time to run a full manual regression test each time. Unit tests can step into the breach and give a high level of confidence that a merge has not broken existing features. This benefit alone repays the time invested in creating unit tests. &lt;p&gt;In summary, SOLID code is mergeable code. SOLID code is also unit testable code, and merges verified by unit tests are the safest kind of merges. If your development process involves working on parallel branches, you will save yourself a lot of pain by mastering the SOLID principles, and protecting legacy features with good unit test coverage.&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories>
    <category>Open Closed Principle</category>
    <category>Liskov Substitution Principle</category>
    <category>Single Responsibility Principle</category>
    <category>merging</category>
    <category>Dependency Inversion Principle</category>
    <category>branching</category>
    <category>SOLID</category>
  </categories>
  <comments />
</post>