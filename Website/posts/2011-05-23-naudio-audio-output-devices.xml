<post>
  <title>NAudio Output Devices</title>
  <slug>naudio-audio-output-devices</slug>
  <author>Mark Heath</author>
  <pubDate>2011-05-23 18:10:00</pubDate>
  <lastModified>2011-05-23 18:21:02</lastModified>
  <content>&lt;p&gt;&lt;a href="http://naudio.codeplex.com"&gt;NAudio&lt;/a&gt; supplies wrappers for four different audio output APIs. In addition, some of them support several different modes of operation. This can be confusing for those new to NAudio and the various Windows audio APIs, so in this post I will explain what the four main options are and when you should use them. &lt;/p&gt; &lt;h3&gt;IWavePlayer&lt;/h3&gt; &lt;p&gt;We’ll start off by discussing the common interface for all output devices. In NAudio, each output device implements &lt;strong&gt;IWavePlayer&lt;/strong&gt;, which has an &lt;strong&gt;Init &lt;/strong&gt;method into which you pass the Wave Provider that will be supplying the audio data. Then you can call &lt;strong&gt;Play&lt;/strong&gt;, &lt;strong&gt;Pause &lt;/strong&gt;and &lt;strong&gt;Stop&lt;/strong&gt; which are pretty self-explanatory, except that you need to know that Play only &lt;em&gt;begins &lt;/em&gt;playback. You should only call &lt;strong&gt;Init &lt;/strong&gt;once on a given instance of an IWavePlayer. If you need to play something else, you should &lt;strong&gt;Dispose &lt;/strong&gt;of your output device and create a new one.&lt;/p&gt; &lt;p&gt;You will notice there is no capability to get or set the playback position. That is because the output devices have no concept of position – they just read audio from the WaveProvider supplied until it reaches an end, at which point the &lt;strong&gt;PlaybackStopped &lt;/strong&gt;event is fired (see &lt;a href="/post/naudio-and-playbackstopped-problem"&gt;this post&lt;/a&gt; for more details). Alternatively, you can ignore PlaybackStopped and just call &lt;strong&gt;Stop &lt;/strong&gt;whenever you decide that playback is finished. &lt;/p&gt; &lt;p&gt;You may notice a &lt;strong&gt;Volume&lt;/strong&gt; property on the interface that is marked as [Obsolete]. &lt;em&gt;Don’t use it&lt;/em&gt;. There are better ways of setting the volume in NAudio. For example look at the WaveChannel32 class or in NAudio 1.5 onwards, the SampleChannel class.&lt;/p&gt; &lt;p&gt;Finally there is a &lt;strong&gt;PlaybackState&lt;/strong&gt; property that can report Stopped, Playing or Paused. Be careful with Stopped though, since if you call the &lt;strong&gt;Stop&lt;/strong&gt; method, the PlaybackState will immediately go to Stopped but it may be a few milliseconds before any background playback threads have actually exited.&lt;/p&gt; &lt;h3&gt;WaveOut&lt;/h3&gt; &lt;p&gt;&lt;strong&gt;WaveOut &lt;/strong&gt;should be thought of as the default audio output device in NAudio. If you don’t know what to use, choose WaveOut. It essentially wraps the Windows &lt;strong&gt;waveOut &lt;/strong&gt;APIs, and is the most universally supported of all the APIs. &lt;/p&gt; &lt;p&gt;The &lt;strong&gt;WaveOut&lt;/strong&gt; object allows you to configure several things before you get round to calling Init. Most common would be to change the &lt;strong&gt;DeviceNumber &lt;/strong&gt;property. –1 indicates the default output device, while 0 is the first output device (usually the same in my experience). To find out how many WaveOut output devices are available, query the static &lt;strong&gt;WaveOut.DeviceCount &lt;/strong&gt;property.&lt;/p&gt; &lt;p&gt;You can also set &lt;strong&gt;DesiredLatency&lt;/strong&gt;, which is measured in milliseconds. This figure actually sets the &lt;em&gt;total &lt;/em&gt;duration of all the buffers. So in fact, you could argue that the real latency is shorter. In a future NAudio, I might reduce confusion by replacing this with a BufferDuration property. By default the DesiredLatency is 300ms, which should ensure a smooth playback experience on most computers. You can also set the &lt;strong&gt;NumberOfBuffers&lt;/strong&gt; to something other than its default of 2 although 3 is the only other value that is really worth using.&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt; &lt;p&gt;One complication with WaveOut is that there are several different “callback models” available. Understanding which one to use is important. Callbacks are used whenever WaveOut has finished playing one of its buffers and wants more data. In the callback we read from the source wave provider and fill a new buffer with the audio. It then queues it up for playback, assuming there is still more data to play. As with all output audio driver models, it is imperative that this happens as quickly as possible, or your output sound will stutter.&lt;/p&gt; &lt;h4&gt;New Window&lt;/h4&gt; &lt;p&gt;This is the default and recommended approach if you are creating a WaveOut object from the GUI thread of a Windows Forms or WPF application. Whenever WaveOut wants more data it posts a message that is handled by the Windows message pump of an invisible new window. You get this callback model by default when you call the empty WaveOut constructor. However, it will not work on a background thread, since there is no message pump.&lt;/p&gt; &lt;p&gt;One of the big benefits of using this model (or the Existing Window model) is that &lt;em&gt;everything &lt;/em&gt;happens on the same thread. This protects you from threading race conditions where a reposition happens at the same time as a read.&lt;/p&gt; &lt;p&gt;&lt;em&gt;note: The reason for using a new window instead of an existing window is to eliminate bugs that can happen if you start one playback before a previous one has finished. It can result in WaveOut picking up messages it shouldn’t.&lt;/em&gt;&lt;/p&gt; &lt;h4&gt;Existing Window&lt;/h4&gt; &lt;p&gt;Existing Window is essentially the same callback mechanism as New Window, but you have to pass in the handle of an existing window. This is passed in as an IntPtr to make it compatible with WPF as well as WinForms. The only thing to be careful of with this model is using multiple concurrent instances of WaveOut as they will intercept each other’s messages (I may fix this in a future version of NAudio).&lt;/p&gt; &lt;p&gt;&lt;em&gt;note: with both New and Existing Window callback methods, audio playback will deteriorate if your windows message pump on the GUI thread has too much other work to do. &lt;/em&gt;&lt;/p&gt; &lt;h4&gt;Function Callback&lt;/h4&gt; &lt;p&gt;Function callback was the first callback method I attempted to implement for NAudio, and has proved the most problematic of all callback methods. Essentially you can give it a function to callback, which seems very convenient, these callbacks come from a thread within the operating system.&lt;/p&gt; &lt;p&gt;To complicate matters, some soundcards really don’t like two threads calling waveOut functions at the same time (particularly one calling waveOutWrite while another calls waveOutReset). This in theory would be easily fixed with locks around all waveOut calls, but some audio drivers call the callbacks from another thread while you are calling waveOutReset, resulting in deadlocks.&lt;/p&gt; &lt;p&gt;I am pretty sure that in NAudio 1.5 all the potential deadlocks have been chased out. Until recently Function callbacks have been the only way to play audio through WaveOut on a non-GUI thread in NAudio. But with NAudio 1.5 there is now also the Event callback, which, once it has has an appropriate amount of testing, will become the recommended alternative to windowed callbacks for those wanting to play audio on background threads.&lt;/p&gt; &lt;h4&gt;Event Callback&lt;/h4&gt; &lt;p&gt;New to NAudio 1.5, this is currently implemented in the &lt;strong&gt;WaveOutEvent &lt;/strong&gt;class, although I may try to think of a way of making event callbacks an option within the WaveOut class. This is implemented similar to WASAPI and DirectSound. A background thread simply sits around filling up buffers when they become empty. To help it respond at the right time, an event handle is set to trigger the background thread that a buffer has been returned by the soundcard and is in need of filling again.&lt;/p&gt; &lt;p&gt;&lt;em&gt;note: WaveOut also supports a No Callback mode, which currently isn’t implemented in NAudio, but it would be very easy to change WaveOutEvent to support it. Essentially instead of waiting on an event handle, you sleep for a bit (half the buffer duration would be sensible) and then wake up to see if any of the buffers need filling.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;note 2: there is one final WaveOut callback model I haven’t mentioned and that is thread callback. I don’t think it offers anything the other models don’t have, but you give it a thread ID and it posts messages to the thread. The thread would need to call Application.Run to instantiate a message pump, and so if implemented, this method could also enable the Window callback methods to work on a background thread.&lt;/em&gt;&lt;/p&gt; &lt;h3&gt;DirectSoundOut&lt;/h3&gt; &lt;p&gt;DirectSound is a good alternative if for some reason you don’t want to use WaveOut since it is simple and widely supported.&lt;/p&gt; &lt;p&gt;To select a specific device with DirectSound, you can call the static &lt;strong&gt;DirectSoundOut.Devices&lt;/strong&gt; property which will let you get at the GUID for each device, which you can pass into the DirectSoundOut constructor. Like WaveOut, you can adjust the latency (overall buffer size),&lt;/p&gt; &lt;p&gt;DirectSoundOut uses a background thread waiting to fill buffers (same as WaveOut with event callbacks). This is a reliable and uncomplicated mechanism, but as with any callback mechanism that uses a background thread, you must take responsibility yourself for ensuring that repositions do not happen at the same time as reads (although some of NAudio’s built-in WaveStreams can protect you from getting this wrong).&lt;/p&gt; &lt;h3&gt;WasapiOut&lt;/h3&gt; &lt;p&gt;WASAPI is the latest and greatest Windows audio API, introduced with Windows Vista. But just because it is newer doesn’t mean you should use it. In fact, it can be a real pain to use, since it is much more fussy about the format of the WaveProvider passed to its Init function and will not perform resampling for you.&lt;/p&gt; &lt;p&gt;To select a specific output device, you need to make use of the MMDeviceEnumerator class, which can report the available audio “endpoints” in the system.&lt;/p&gt; &lt;p&gt;WASAPI out offers you a couple of configuration options. The main one is whether you open in shared or exclusive mode. In exclusive mode, your application requests exclusive access to the soundcard. This is only recommended if you need to work at very low latencies. You can also choose whether event callbacks are used. I recommend you do so, since it enables the background thread to get on with filling a new buffer as soon as one is needed.&lt;/p&gt; &lt;p&gt;Why would you use WASAPI? I would only recommend it if you want to work at low latencies or are wanting exclusive use of the soundcard. Remember that WASAPI is not supported on Windows XP. However, in situations where WASAPI would be a good choice, ASIO out is often a better one…&lt;/p&gt; &lt;h3&gt;AsioOut&lt;/h3&gt; &lt;p&gt;ASIO is the de-facto standard for audio interface drivers for recording studios. All professional audio interfaces for Windows will come with ASIO drivers that are designed to operate at the lowest latencies possible. ASIO is probably a better choice than WASAPI for low latency applications since it is more widely supported (you can use ASIO on XP for example).&lt;/p&gt; &lt;p&gt;ASIO Out devices are selected by name. Use the AsioOut.GetDriverNames() to see what devices are available on your system. Note that this will return all &lt;em&gt;installed &lt;/em&gt;ASIO drivers. It does not necessarily mean that the soundcard is currently connected in the case of an external audio interface, so Init can fail for that reason.&lt;/p&gt; &lt;p&gt;ASIO drivers support their own customised settings GUI. You can access this by calling &lt;strong&gt;ShowControlPanel()&lt;/strong&gt;. Latencies are usually set within the control panel and are typically specified in samples. Remember that if you try to work at a really low latency, your input WaveProvider’s Init function needs to be really fast.&lt;/p&gt; &lt;p&gt;ASIO drivers can process data in a whole host of native WAV formats (e.g. big endian vs little endian, 16, 24, 32 bit ints, IEEE floats etc), not all of which are currently supported by NAudio. If ASIO Out doesn’t work with your soundcard, post a message on the NAudio discussion groups, as it is fairly easy to add support for another format.&lt;/p&gt;</content>
  <ispublished>true</ispublished>
  <categories>
    <category>NAudio</category>
  </categories>
  <comments>
    <comment isAdmin="false" isApproved="true" id="37daa967-532b-4bc8-8e81-4c9dc0f1d22b">
      <author>Anonymous</author>
      <email>noreply@blogger.com</email>
      <website />
      <ip />
      <userAgent />
      <date>2014-03-04 14:01:54</date>
      <content>Hi mark !&lt;br /&gt;Kudos on the great post !! I am trying to use Naudio to play sound in both speakers and headsets (when plugged in) at the same time, by giving the same wave file to different output devices. Do you think that will work ? Appreciate your help !</content>
    </comment>
    <comment isAdmin="false" isApproved="true" id="5dae2e64-f232-404c-b1ad-946ed4bc64e7">
      <author>Anonymous</author>
      <email>noreply@blogger.com</email>
      <website />
      <ip />
      <userAgent />
      <date>2014-03-04 14:03:44</date>
      <content>Hi Mark ! Kudos on the great post !&lt;br /&gt;I am trying to use Naudio to play sound on both speakers and headset (when plugged). Do you think that will work ? Appreciate your comment.</content>
    </comment>
    <comment isAdmin="false" isApproved="true" id="5a5a1e9a-06c8-40df-ab3a-49d9a8bf5084">
      <author>Mark H</author>
      <email>noreply@blogger.com</email>
      <website>http://www.blogger.com/profile/17900587357903273800</website>
      <ip />
      <userAgent />
      <date>2014-03-04 14:37:09</date>
      <content>yes, but create a separate file reader for each device, otherwise the sound will end up being sliced up and played partly out of each device</content>
    </comment>
    <comment isAdmin="false" isApproved="true" id="e661857b-8f38-472f-8b1d-cdeb23d7f032">
      <author>JasonB</author>
      <email>noreply@blogger.com</email>
      <website />
      <ip />
      <userAgent />
      <date>2014-03-25 13:57:24</date>
      <content>I&amp;#39;ve used NAudio on several projects and it&amp;#39;s awesome. I&amp;#39;m currently struggling with a requirement that I use the default WPF mediaelement control to play a video, but allow the user to choose the playback device from any active device. Most of the examples I see assume NAudio will be handling both device selection and playback. &lt;br /&gt;&lt;br /&gt;It seems from most of my research that mediaelement only wants to play on the default device, and that setting the default device programmatically is kept intentionally difficult (understandably so). &lt;br /&gt;&lt;br /&gt;Is it possible to use NAudio to select the device and have the mediaelement do the playback?&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</content>
    </comment>
    <comment isAdmin="false" isApproved="true" id="8e702874-0f65-463c-b22b-1c9fc3e1d05b">
      <author>Anonymous</author>
      <email>noreply@blogger.com</email>
      <website />
      <ip />
      <userAgent />
      <date>2014-03-27 11:03:47</date>
      <content>Trying to play sound on both speakers and headset. I think i am a step away. Here is the sample code :&lt;br /&gt;&lt;br /&gt; public void detectDevices()&lt;br /&gt;    {&lt;br /&gt;        int waveOutDevices = WaveOut.DeviceCount;&lt;br /&gt;        switch (waveOutDevices)&lt;br /&gt;        {&lt;br /&gt;            case 1:&lt;br /&gt;                var wave1 = new WaveOut();&lt;br /&gt;                wave1.DeviceNumber = 0;&lt;br /&gt;                playSound(0); &lt;br /&gt;&lt;br /&gt;                break;&lt;br /&gt;            case 2:&lt;br /&gt;                var wave2 = new WaveOut();&lt;br /&gt;                wave2.DeviceNumber = 0;&lt;br /&gt;                playSound(0);&lt;br /&gt;&lt;br /&gt;                var wave3 = new WaveOut();&lt;br /&gt;                wave3.DeviceNumber = 1;&lt;br /&gt;                playSound(1); &lt;br /&gt;&lt;br /&gt;                break;&lt;br /&gt;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void playSound(int deviceNumber)&lt;br /&gt;    {&lt;br /&gt;        disposeWave();// stop previous sounds before starting&lt;br /&gt;        waveReader = new NAudio.Wave.WaveFileReader(fileName);&lt;br /&gt;        var waveOut = new NAudio.Wave.WaveOut();&lt;br /&gt;        waveOut.DeviceNumber = deviceNumber;&lt;br /&gt;        output = waveOut;&lt;br /&gt;        output.Init(waveReader);&lt;br /&gt;        output.Play();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    public void disposeWave()&lt;br /&gt;    {&lt;br /&gt;        if (output != null)&lt;br /&gt;        {&lt;br /&gt;            if (output.PlaybackState == NAudio.Wave.PlaybackState.Playing)&lt;br /&gt;            {&lt;br /&gt;                output.Stop();&lt;br /&gt;                output.Dispose();&lt;br /&gt;                output = null;&lt;br /&gt;            }&lt;br /&gt;        }&lt;br /&gt;        if (wave != null)&lt;br /&gt;        {&lt;br /&gt;            wave.Dispose();&lt;br /&gt;            wave = null;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;case eSelector.startIncomingRinging:&lt;br /&gt;&lt;br /&gt;                fileName = (&amp;quot;Ring.wav&amp;quot;);&lt;br /&gt;                detectDevices();</content>
    </comment>
  </comments>
</post>