<post>
  <title>A Few Thoughts on TDD and Why we Don’t Always Use it</title>
  <slug>a-few-thoughts-on-tdd-and-why-we-dont</slug>
  <author>Mark Heath</author>
  <pubDate>2014-05-08 22:55:00</pubDate>
  <lastModified>2014-05-08 22:55:09</lastModified>
  <content>&lt;p&gt;I’m sure many of you have been following the recent TDD blogosphere altercation with interest. Just in case you you haven’t, here’s a quick catchup:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html"&gt;TDD is dead. Long Live Testing&lt;/a&gt; (David Heinemeier Hansson)&lt;/li&gt; &lt;li&gt;&lt;a href="http://blog.8thlight.com/uncle-bob/2014/04/25/MonogamousTDD.html"&gt;Monogamous TDD&lt;/a&gt; (Uncle Bob)&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.gilzilberfeld.com/2014/04/tdd-is-dead-lets-kill-messenger-instead.html"&gt;TDD is dead? Let’s Kill the Messenger Instead&lt;/a&gt; (Gil Zilberfeld)&lt;/li&gt; &lt;li&gt;&lt;a href="http://blog.8thlight.com/uncle-bob/2014/04/30/When-tdd-does-not-work.html"&gt;When TDD doesn’t work&lt;/a&gt; (Uncle Bob)&lt;/li&gt; &lt;li&gt;&lt;a href="http://codeofrob.com/entries/professionalism-and-tdd-in-the-future.html"&gt;Professionalism and TDD in the Future&lt;/a&gt; (Rob Ashton)&lt;/li&gt; &lt;li&gt;&lt;a href="http://www.bitnative.com/2014/05/01/the-tdd-divide/"&gt;The TDD Divide: Everyone is Right&lt;/a&gt; (Cory House)&lt;/li&gt; &lt;li&gt;&lt;a href="http://blog.8thlight.com/uncle-bob/2014/05/01/Design-Damage.html"&gt;Test Induced Design Damage?&lt;/a&gt; (Uncle Bob)&lt;/li&gt; &lt;li&gt;&lt;a href="http://blog.8thlight.com/uncle-bob/2014/05/02/ProfessionalismAndTDD.html"&gt;Profesionalism and TDD (Reprise)&lt;/a&gt; (Uncle Bob)&lt;/li&gt; &lt;li&gt;&lt;a href="http://paulhammant.com/2014/05/08/tdd-when-you-cant-refactor"&gt;TDD When You Can’t Refactor&lt;/a&gt; (Paul Hammant)&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;Read all that? Good. As you can see there are some strong opinions strongly held on this subject.&lt;/p&gt; &lt;p&gt;My own thoughts on the subject are quite simple. TDD is a fantastic idea that turns out to be quite difficult to implement, especially at first. There are several reasons for this.&lt;/p&gt; &lt;h3&gt;Slow Progress&lt;/h3&gt; &lt;p&gt;The most obvious is that adopting TDD slows you down initially. This is true of any new way of working. If you decide you’re going to stop using the mouse for a day and only use keyboard shortcuts, it’s going to be a frustrating experience and in all likelihood you’ll be tempted to give up within minutes of starting. But if you can push through that pain barrier and accept the initial slow-down, you’ll reap the benefits later.&lt;/p&gt; &lt;p&gt;But there are two other reasons we have for not using TDD that I want to highlight in this post. They are:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;“This code is too simple to bother using TDD”&lt;/li&gt; &lt;li&gt;“This code is too complicated to use TDD”&lt;/li&gt;&lt;/ul&gt; &lt;h3&gt;Too Simple for TDD&lt;/h3&gt; &lt;h3&gt;&lt;/h3&gt; &lt;p&gt;Often early on in the lifetime of a piece of software, you already have in your head a large portion of the design and architecture. And if you’re an experienced developer, you probably have a very good instinct for what that design looks like. You just want to turn it into code as quickly as possible. TDD seems redundant during this rapid prototyping phase, so you skip it.&lt;/p&gt; &lt;p&gt;The trouble is, now when you start evolving that initial design further, a unit test suite would be really useful. But you haven’t got one, and retrofitting unit tests to existing code is slow and painful. So this is the reason why I think a lot of developers who have embraced TDD in theory, end up not actually using it in practice. We lack the self-discipline to start the way we mean to go on.&lt;/p&gt; &lt;h3&gt;Too Complicated for TDD&lt;/h3&gt; &lt;p&gt;But let’s look at the other side of the equation. Sometimes we really want to use TDD, but are thwarted because it just seems too difficult to do.&lt;/p&gt; &lt;p&gt;I’m glad Uncle Bob admitted in one of his many posts on TDD that &lt;a href="http://blog.8thlight.com/uncle-bob/2014/04/30/When-tdd-does-not-work.html"&gt;it doesn’t fit all types of development&lt;/a&gt;. There are many types of coding where TDD isn’t a natural fit, and I have several examples from a series I wrote a while back:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="/post/test-resistant-code-and-battle-for-tdd"&gt;Test Resistant Code #1 – External Dependencies&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/post/test-resistant-code-2markup-is-code-too"&gt;Test Resistant Code #2 – Markup is Code Too&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/post/test-resistant-code-3algorithms"&gt;Test Resistant Code #3 – Algorithms&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/post/test-resistant-code-4third-party"&gt;Test Resistant Code #4 – Third Party Frameworks&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="/post/test-resistant-code-5threading"&gt;Test Resistant Code #5 – Threading&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;What do we do about code like this? Uncle Bob freely admits that much of this type of code requires “fiddling” and is outside the domain of unit tests. And I agree with him. All we need to do is ensure that the business logic isn’t intertwined with this untestable code, in order that it can be written test driven.&lt;/p&gt; &lt;p&gt;Now I don’t know if I’m a special case, but many applications I write are almost exclusively made up of test-resistant code. For example, I write a lot of audio applications, which play or record sounds and display custom waveform visualisations. The amount of code that I can meaningfully unit test is sometimes less than 5% of the total code in the application. &lt;/p&gt; &lt;p&gt;This means that for me to write these applications “professionally”, as a responsible software craftsman, TDD is at best only a small part of the answer. So while I’m happy to keep enthusiastically promoting TDD (and trying to be better disciplined to use it more consistently), I don’t think it’s the final word on writing quality code. I think there’s still plenty of scope for new practices to be discovered and frameworks to be created that help us test those parts of our code which ordinary unit tests just can’t reach.&lt;/p&gt; &lt;p&gt;I have some thoughts on what those might look like, but that’s for another blog post.&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories>
    <category>unit testing</category>
    <category>TDD</category>
  </categories>
  <comments />
</post>