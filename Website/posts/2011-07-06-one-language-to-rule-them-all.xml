<post>
  <title>One Language to Rule them All</title>
  <slug>one-language-to-rule-them-all</slug>
  <author>Mark Heath</author>
  <pubDate>2011-07-06 22:36:00</pubDate>
  <lastModified>2011-07-06 22:36:54</lastModified>
  <content>&lt;p&gt;You may have heard the story of the “&lt;a href="http://www.biblegateway.com/passage/?search=Genesis+11%3A1-9&amp;amp;version=NIV"&gt;tower of Babel&lt;/a&gt;”. The story goes that one day, the people of the earth decided to build a great tower. It would be a monument to the greatness of humanity. But God objected to their pride and intervened to thwart their building program. His technique was not to strike the tower down with an earthquake, or strike the builders down with illness. Instead, he opted for a simple yet effective solution: he “confused the language” and the building project was soon abandoned. &lt;em&gt;Inability to communicate doomed the project to failure.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;This ancient tale is a remarkably fitting parable for the state of modern programming. Even the smallest of miscommunications, such as requirements not properly understood, or two components in the system using different units of measure can cause the premature demise of entire software projects.&lt;/p&gt; &lt;p&gt;The analogy works on a wider scale too. Imagine what we as a software development community could build if we shared a common programming language. All the wastage of ‘porting’ libraries from one framework to another would be eliminated. Instead of reinventing the same development tools over and over for every new language, we could focus on genuine innovation.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;The Last Programming Language&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;And this is the point made by Robert C Martin at the NDC 2011 conference, in a fascinating talk entitled “&lt;a href="http://ndc2011.macsimum.no/SAL7/Onsdag/1020-1120.wmv"&gt;Clojure – The Last Programming Language&lt;/a&gt;”. &lt;/p&gt; &lt;p&gt;He begins by arguing that &lt;strong&gt;we’ve already fully explored the domain of programming languages&lt;/strong&gt;. In other words, we have experimented with all the &lt;em&gt;types &lt;/em&gt;of languages that there are. Or to put it another way, the new languages we keep inventing are just refinements or rearrangements of ideas from existing languages. It’s a slightly depressing thought in some ways – expect no new revolutionary paradigms – we’ve tried it all already.&lt;/p&gt; &lt;p&gt;Whether or not he is right about his first claim, his proposal for the development community to &lt;strong&gt;standardise on a single language &lt;/strong&gt;certainly grabbed my attention. Before dismissing it out of hand as a pipe dream, it is worth pondering the many benefits it would bring.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;You would not need to hire a C#/Java/Ruby/C programmer. You’d just need to hire a programmer.  &lt;li&gt;All platforms and frameworks would be built in that language. No need for all this NUnit, JUnit, PyUnit, Runit business. We’d build on top of what had gone before instead of continually having to reinvent it for every new language. &lt;li&gt;Articles with example code would be immediately understandable to all developers&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;&lt;strong&gt;Can we agree on anything?&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;But could developers really agree on one programming language? The idea seems almost preposterous. Uncle Bob counters that other industries have gone through the same transition (e.g. biologists, chemists, medicine, mathematics). Eventually the benefits of a lingua franca win through despite the attachment people inevitably feel to their native tongue.&lt;/p&gt; &lt;p&gt;He also points out that this already happened once with C, which is one of those few languages that can genuinely be used to develop on almost every platform. This for me is the big sticking point in seeing Uncle Bob’s vision become a reality. The one language must be able to develop for every platform, server, client, embedded, handheld. It must be usable for every type of development – desktop apps, websites, games, services, device drivers, nuclear power stations. I’m not sure such a language exists.&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Features of the final language&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;But let’s suspend disbelief for a moment and ask what features the final language should have. Uncle Bob’s wishlist included features such as:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Not controlled by a corporation.  &lt;li&gt;Garbage collected. (I have mixed feelings on this one given .NET’s inability to do low latency audio well) &lt;li&gt;Polymorphic  &lt;li&gt;Runs on a virtual machine  &lt;li&gt;Able to modify itself at runtime like Ruby (homoiconic)  &lt;li&gt;Pared down syntax  &lt;li&gt;Functional  &lt;li&gt;Hybrid, i.e. Multi-paradigm (support, don’t enforce paradigms)  &lt;li&gt;Simple  &lt;li&gt;Provide access to existing frameworks  &lt;li&gt;Structured (no goto)  &lt;li&gt;Fast  &lt;li&gt;Textual  &lt;li&gt;Dynamically typed (the talk includes an interesting discussion on this).&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;His proposed language was &lt;a href="http://clojure.org/"&gt;Clojure&lt;/a&gt;. It seems an interesting enough language, although I can’t say I warm to all the parentheses. &lt;/p&gt; &lt;p&gt;&lt;strong&gt;A step in the right direction…&lt;/strong&gt;&lt;/p&gt; &lt;p&gt;In any case, I think that if his vision were to become a reality, we would first have to pick a virtual machine. The two most obvious candidates are the &lt;a href="http://en.wikipedia.org/wiki/Java_Virtual_Machine"&gt;JVM&lt;/a&gt; and the &lt;a href="http://en.wikipedia.org/wiki/Common_Language_Runtime"&gt;CLR&lt;/a&gt;, both of which now support a whole host of languages (Clojure can run on either). The CLR may even have the upper hand due to products like &lt;a href="http://www.mono-project.com/Main_Page"&gt;Mono&lt;/a&gt; which makes it a genuine open source option and available on a very broad range of platforms, although I suspect its ties with Microsoft would generate a lot of resistance. &lt;/p&gt; &lt;p&gt;Libraries that are compiled for a virtual machine like the CLR effectively appear as native libraries for all languages that compile to the same byte code, meaning that there is at least some reduction in the amount of reinvention and relearning required when you switch languages – the libraries can come with you even if the language syntax doesn’t. Another benefit is that often the byte code for a VM can be translated into other languages by a tool, allowing at least some level of automated translation between languages. Maybe someone could invent a browser plugin that automatically converts any code you view in a web-page into the language of your choice – a kind of Google translate for programming languages.&lt;/p&gt; &lt;p&gt;What do you think? Could we agree on a virtual machine, and then get to work on picking a smaller subset of languages to program it with? Or is Uncle Bob’s idea a pipedream? Will we ever get to one common language or will God step in and mix it all up again, just to keep us humble.&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories />
  <comments>
    <comment isAdmin="false" isApproved="true" id="e4deaf29-231f-4b76-941a-1c3d93be6e5c">
      <author>Anonymous</author>
      <email>noreply@blogger.com</email>
      <website />
      <ip />
      <userAgent />
      <date>2011-09-07 12:59:54</date>
      <content>To be honest, the idea of interoperability between the languages is already manifested in the .NET and Java frameworks.&lt;br /&gt;But I have to admit as former C/C++, COBOL, VB6, Java and now C# developer that I really feel a kind of discomfort at my first view on Clojure. It really looks like a big step BACK in what I meant to be an easy-to-learn enterprise grade language. It just looks like a bad behaved mix of PHP/Lisp slang.&lt;br /&gt;&lt;br /&gt;Anyway I would be willing to learn anything if anyone can make me believe that I can get my work done more faster or accurate - and more MAINTAINABLE - than using C# or Java.</content>
    </comment>
  </comments>
</post>