<post>
  <title>Codebase Reformation</title>
  <slug>codebase-reformation</slug>
  <author>Mark Heath</author>
  <pubDate>2010-09-14 09:51:00</pubDate>
  <lastModified>2010-09-14 09:51:55</lastModified>
  <content>&lt;p&gt;I am currently looking into how the architecture of a very large software product (now over 1 million lines of code) can be improved to make it more maintainable and extensible into the future. Inevitably on a project of its size, many of the assumptions and expectations held at the beginning have not proved to be correct. The product has been extended in ways that no one could have foreseen. Sometimes large amounts of technical debt has been introduced as we rushed to meet a vital deadline. New technologies have emerged (it was started as a .NET 1.1 product) which are more suited to the task than anything that was around back then. And additionally, those of us on the development team have grown as programmers during the time. What looked like good code to us back then now looks decidedly poor.&lt;/p&gt;  &lt;p&gt;So my task over the last few months has been to produce a document of recommendations about what architectural changes should be made to improve things. I have a good idea of where we are now, and where we ought to be going. But there is one thing that concerns me, and it is summed up well in the following quote:&lt;/p&gt;  &lt;blockquote&gt;   &lt;p&gt;The reformer is always &lt;strong&gt;right&lt;/strong&gt; &lt;strong&gt;about&lt;/strong&gt; &lt;strong&gt;what&lt;/strong&gt; &lt;strong&gt;is&lt;/strong&gt; &lt;strong&gt;wrong&lt;/strong&gt;. He is generally &lt;strong&gt;wrong&lt;/strong&gt; &lt;strong&gt;about&lt;/strong&gt; &lt;strong&gt;what&lt;/strong&gt; &lt;strong&gt;is&lt;/strong&gt; &lt;strong&gt;right&lt;/strong&gt;. —G.K. Chesterton&lt;/p&gt; &lt;/blockquote&gt;  &lt;p&gt;In other words, it is one thing to look at a codebase and observe all the things that are wrong about it. It is another thing entirely to know what the correct solution is. Experience tells us that simply adopting a new technology (“let’s use IoC containers”, “let’s use WPF”) will typically solve one set of problems but introduce another set. &lt;/p&gt;  &lt;p&gt;The correct approach in my view is to recognise that we are trying to move between two moving targets. In other words, “where we are” is always moving, since any living codebase is being continually worked on. But also, “where we want to be” is also a moving target, as we grow in our understanding of what the system needs to do, and what constitutes a well-architected system.&lt;/p&gt;  &lt;p&gt;Bearing this in mind, it is a mistake therefore to imagine that you can, or should, attempt to “fix” the architecture of a large system in one gigantic refactoring session. There may be a case for making certain major changes to prepare the way for specific new features, and address significant areas of technical debt, but in my view, the best approach to codebase reformation is continual refactoring, allowing our vision of where we are heading to be modified as our horizons expand.&lt;/p&gt;  </content>
  <ispublished>true</ispublished>
  <categories>
    <category>Refactoring</category>
    <category>architecture</category>
    <category>Technical Debt</category>
  </categories>
  <comments />
</post>