<post>
  <title>Test resistant code and the battle for TDD</title>
  <slug>test-resistant-code-and-battle-for-tdd</slug>
  <author>Mark Heath</author>
  <pubDate>2011-06-24 20:34:00</pubDate>
  <lastModified>2013-09-30 16:15:18</lastModified>
  <content>&lt;p&gt;I have been watching a number of videos from the &lt;a href="http://ndc2011.no/index.aspx"&gt;NDC 2011&lt;/a&gt; conference recently, and noticed a number of speakers expressing the sentiment that &lt;strong&gt;TDD has won.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;By “won”, they don’t mean that everyone is using it, because true TDD practitioners are still very much in the minority, Even those who claim to be doing TDD are in reality only doing it &lt;em&gt;sometimes&lt;/em&gt;. In fact, I would suggest that even the practice of writing unit tests for everything, let alone writing them first, is far from being the norm in the industry.&lt;/p&gt;&lt;p&gt;Of course, what they mean is that &lt;em&gt;the argument has been won&lt;/em&gt;. No prominent thought-leaders are speaking out against TDD; its benefits are clear and obvious. The theory is that, it is only a matter of time before we know no other way of working.&lt;/p&gt;&lt;p&gt;Or is it?&lt;/p&gt;&lt;p&gt;There is a problem with doing TDD in languages like C# that its most vocal proponents are not talking enough about. And that is that a lot of the code we write is &lt;em&gt;test resistant&lt;/em&gt;. By test resistant, I don’t mean “impossible to test”. I just mean that the effort required to shape it into a form that can be tested is so great that even if we are really sold on the idea of TDD, we give up in frustration once we actually try it. &lt;/p&gt;&lt;p&gt;I’ve got a whole list of different types of code that I consider to be “test-resistant”, but I’ll just focus in on one for the purposes of this post. And that is code that has lots of &lt;strong&gt;external dependencies&lt;/strong&gt;. TDD is quite straightforward if you happen to be writing a program to calculate the prime factors of a number; you don’t have any significant external dependencies to worry about. The same is largely true if you happen to be writing a unit testing framework or an IoC container. But for many, and quite probably the majority of us, the code we write interacts with all kinds of nasty hard to test external &lt;em&gt;stuff&lt;/em&gt;. And that stuff is what gets in our way.&lt;/p&gt;&lt;h3&gt;External dependencies&lt;/h3&gt;&lt;p&gt;External dependencies come in many flavours. Does your class talk to the file-system or to a database? Does it inherit from a UserControl base class? Does it create threads? Does it talk across the network? Does it use a third party library of any sort? If the answer to any of these questions is yes, the chances are your class is test-resistant.&lt;/p&gt;&lt;p&gt;Such classes can of course be constructed and have their methods called by an automated testing framework, but those tests will be “integration” tests. Their success depends on the environment in which they are run. Integration tests have their place, but if large parts of our codebase can only be covered by integration tests, then we have lost the benefits of TDD. We can’t quickly run the tests and prove that our system is still working.&lt;/p&gt;&lt;p&gt;Suppose we draw a dependency diagram of all the classes in our application arranged inside a circle. If a class has any external dependencies we’ll draw it on the edge of the circle. If a class only depends on other classes &lt;em&gt;we &lt;/em&gt;wrote, we’ll draw it in the middle. We might end up with something looking like this:&lt;/p&gt;&lt;p&gt;&lt;a href="/posts/files/test-resistant-code-and-battle-for-tdd-1.png"&gt;&lt;img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="external-dependencies" border="0" alt="Dependencies Diagram" src="/posts/files/test-resistant-code-and-battle-for-tdd-1.png" width="556" height="368"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;In my diagram, the green squares in the middle are the classes that we will probably be able to unit test without too much pain. They depend only on other code we have written (or on trivial to test framework classes like String, TimeSpan, Point etc).&lt;/p&gt;&lt;p&gt;The orange squares represent classes that we &lt;em&gt;might&lt;/em&gt; be able to ‘unit’ test, since file systems and databases are reasonably predictable. We could create a test database to run against, or use temporary files that are deleted after the test finishes.&lt;/p&gt;&lt;p&gt;The red squares represent classes that will be a real pain to test. If we must talk to a web-service, what happens when it is not available? If we are writing a GUI component, we probably have to use some kind of unwieldy automation tool to create it and simulate mouse-clicks and keyboard presses, and use bitmap comparisons to see if the right thing happened.&lt;/p&gt;&lt;h3&gt;DIP to the rescue?&lt;/h3&gt;&lt;p&gt;But hang on a minute, don’t we have a solution to this problem already? It’s called the “Dependency Inversion Principle”. Each and every external dependency should be hidden behind an &lt;em&gt;interface&lt;/em&gt;. The concrete implementers of those interfaces should write the absolute minimal code to fulfil those interfaces, with no logic whatsoever.&lt;/p&gt;&lt;p&gt;Now suddenly all our business logic has moved inside the circle. The remaining concrete classes on the edge still need to be covered by integration tests, but we can verify all the decisions, algorithms and rules that make up our application using fast, repeatable, in-memory unit tests.&lt;/p&gt;&lt;p&gt;All’s well then. External dependencies are not a barrier to TDD after all. Or are they?&lt;/p&gt;&lt;p&gt;How many interfaces would you actually need to create to get to this utopian state where &lt;em&gt;all &lt;/em&gt;your logic is testable? If the applications you write are anything like the ones I work on, the answer is, a lot.&lt;/p&gt;&lt;h3&gt;IFileSystem &lt;/h3&gt;&lt;p&gt;Let’s work through the file system as an example. We could create IFileSystem and decree that every class in our application that needs to access the disk goes via IFileSystem. What methods would it need to have? A quick scan through the application I am currently working on reveals the following dependencies on static methods in the System.IO namespace:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;File.Exists&lt;br&gt;
&lt;li&gt;File.Delete&lt;br&gt;
&lt;li&gt;File.Copy&lt;br&gt;
&lt;li&gt;File.OpenWrite&lt;br&gt;
&lt;li&gt;File.Open&lt;br&gt;
&lt;li&gt;File.Move&lt;br&gt;
&lt;li&gt;File.Create&lt;br&gt;
&lt;li&gt;File.GetAttributes&lt;br&gt;
&lt;li&gt;File.SetAttributes&lt;br&gt;
&lt;li&gt;File.WriteAllBytes&lt;br&gt;
&lt;li&gt;File.ReadLines&lt;br&gt;
&lt;li&gt;File.ReadAllLines&lt;br&gt;
&lt;li&gt;Directory,Exists&lt;br&gt;
&lt;li&gt;Directory.CreateDirectory&lt;br&gt;
&lt;li&gt;Directory.GetFiles&lt;br&gt;
&lt;li&gt;Directory.GetDirectories&lt;br&gt;
&lt;li&gt;Directory.Delete&lt;br&gt;
&lt;li&gt;DriveInfo.GetDrives&lt;/li&gt;&lt;br&gt;
&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;There’s probably some others that I missed, but that doesn’t seem &lt;em&gt;too &lt;/em&gt;bad. Sure it would take a long time to go through the entire app and make everyone use IFileSystem, but if we had used TDD, then IFileSystem could have been in there from the beginning. We could start off with just a few methods, and then add new ones in on an as-needed basis.&lt;/p&gt;&lt;p&gt;The trouble is, our abstraction layer needs to go deeper than just wrappers for all the static methods on System.IO. For example, Directory.GetFiles returns a FileInfo object. But the &lt;a href="http://msdn.microsoft.com/en-us/library/system.io.fileinfo.aspx"&gt;FileInfo&lt;/a&gt; class has all kinds of methods on it that allow external dependencies to sneak back into our classes via the back door. What’s more, it’s a sealed class, so we can’t fake it for our unit tests anyway. So now we need to create IFileInfo for our IFileSystem to return when you ask for the files in a folder. If we keep going in this direction it won’t be long before we end up writing an abstraction layer for the entire .NET framework class library.&lt;/p&gt;&lt;h3&gt;Interface Explosion&lt;/h3&gt;&lt;p&gt;This is a problem. You could blame Microsoft. Maybe the BCL/FCL should have come with interfaces for &lt;em&gt;everything &lt;/em&gt;that was more than just a trivial data transfer object. That would certainly have made life easier for unit testing. But this would also add literally &lt;em&gt;thousands&lt;/em&gt; of interfaces. And if we wanted to apply the “interface segregation principle” as well, we’d end up needing to make even more interfaces, because the ones we had were a bad fit for the classes that need to consume them.&lt;/p&gt;&lt;p&gt;So for us to do TDD properly in C#, we need to get used to the idea of making &lt;em&gt;lots&lt;/em&gt; of interfaces. It will be like the good old days of C/C++ programming all over again. For every class, you also need to make a header / interface file.&amp;nbsp; &lt;/p&gt;&lt;h3&gt;Mocks to the Rescue?&lt;/h3&gt;&lt;p&gt;Is there another way? Well I suppose we could buy those commercial tools that have the power to replace any concrete dependency with a mock object. Or maybe Microsoft’s &lt;a href="http://research.microsoft.com/en-us/projects/moles/"&gt;Moles&lt;/a&gt; can dig us out of this hole. But are these frameworks solutions to problems we shouldn’t be dealing with in the first place?&lt;/p&gt;&lt;p&gt;There is of course a whole class of languages that doesn’t suffer from this problem at all. And that is &lt;strong&gt;dynamic languages&lt;/strong&gt;. Mocking a dependency is trivial with a dynamically typed language. The concept of interfaces is not needed at all. &lt;/p&gt;&lt;p&gt;This makes me think that &lt;strong&gt;if TDD really is going to win, dynamically typed languages need to win. &lt;/strong&gt;The limited class of problems that a statically typed language can protect us from can quite easily be detected with a good suite of unit tests. It leaves us in a kind of catch 22 situation. Our statically typed languages are hindering us from embracing TDD, but until we are really doing TDD, we’re not ready to let go of the statically typed safety net.&lt;/p&gt;&lt;p&gt;Maybe language innovations like C# 4’s dynamic or the coming compiler as a service in the next .NET will afford enough flexibility to make TDD flow more naturally. But I get the feeling that TDD still has a few battles to win before the war can truly be declared as over.&lt;/p&gt;&lt;p&gt;&lt;i&gt;read the follow-on articles here:&lt;/i&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href="/post/test-resistant-code-2markup-is-code-too"&gt;Test Resistant Code #2 - Markup is Code Too&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/post/test-resistant-code-3algorithms"&gt;Test Resistant Code #3 - Algorithms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/post/test-resistant-code-4third-party"&gt;Test Resistant Code #4 - Third Party Frameworks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="/post/test-resistant-code-5threading"&gt;Test Resistant Code #5 - Threading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;</content>
  <ispublished>true</ispublished>
  <categories>
    <category>Dependency Inversion Principle</category>
    <category>TDD</category>
  </categories>
  <comments />
</post>